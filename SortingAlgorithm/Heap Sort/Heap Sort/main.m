//
//  main.m
//  Heap Sort
//
//  Created by 杨卢青 on 16/9/13.
//  Copyright © 2016年 杨卢青. All rights reserved.
//

#import <Foundation/Foundation.h>



/**
 
 > 二叉堆:
 
 二叉堆是完全二叉树或者是近似完全二叉树。
 
 二叉堆满足两个特性：
 
 1．父结点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
 
 2．每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。
 
 当父结点的键值总是大于或等于任何一个子节点的键值时为最大堆。当父结点的键值总是小于或等于任何一个子节点的键值时为最小堆。
 
 由于其它几种堆（二项式堆，斐波纳契堆等）用的较少，一般将二叉堆就简称为堆。
 
 
 > 堆的存储:
 
 一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。
 
 它的左右子结点下标分别为2 * i + 1和2 * i + 2。如第0个结点左右子结点下标分别为1和2。
 
 > 堆的操作——插入删除
 
 1. 建立堆: 数组具有对应的树表示形式. 通过重新排列元素, 可以建立一颗"堆化"的树
 
 2. 插入一个元素: 新元素被加入到数组最后, 随后树被更新以回复堆次序.
 
 3. 删除一个元素: 删除总是发生在A[0]处. 表中最后一个元素用来填补空缺, 最后更新结果树
 
 > 堆的插入
  每次插入都是将新数据放在数组最后, 可以发现从这个新数据的父节点到根节点必然成为一个有序的序列, 现在的任务是将这个新数据插入到有序数据中, 这就类似于直接插入排序中将一个数据并入到有序区间中
 */

//新加入i节点, 其父节点为(i - 1) / 2, i下标是数组最后一个
void MinHeapFixup(int a[], int i) {
  int j, temp;
  
  temp = a[i];
  j = (i - 1) / 2;  //父节点
  while (j >= 0 && i != 0) {
    if (a[j] <= temp)
      break;
    
    a[i] = a[j];  //把较大的子节点往下移动, 替换它的子节点
    i = j;
    j = (i - 1) / 2;
  }
  a[i] = temp;
}

void swap(int *left, int *right)
{
		*left ^= *right;
		*right ^= *left;
		*left ^= *right;
}

void MinHeapFixup2(int a[], int i) {
  for (int j = (i - 1) / 2; (j >= 0 && i != 0 && a[i] > a[j]); i = j, j = (i - 1) / 2) {
    swap(&a[i], &a[j]);
  }
}

/**
  堆的删除:
  按定义, 堆中每次都只能删除第0个数据, 为了便于重建堆, 实际操作是将最后一个数据的值赋给根节点,
  再从根节点开始进行一次从上向下的调整. 调整时先在左右儿子节点中找最小的, 如果父节点比这个最小的子节点还小, 说明不需要调整了, 反之, 将父节点和它交换后再考虑后面的节点. 数据下沉.
 */

int main(int argc, const char * argv[]) {
	@autoreleasepool {
	    // insert code here...
	    NSLog(@"Hello, World!");
	}
    return 0;
}


